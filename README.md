# Обзор паттернов GOF на Java

## Назначение репозитория
Репозиторий содержит компактные примеры паттернов проектирования «Банды четырёх» на Java 17. Реализации сгруппированы по семействам и демонстрируют, как применять шаблоны в прикладных сценариях интеграции, построения иерархий и оптимизации ресурсов. Коллекция полезна для архитекторов, тимлидов и разработчиков, которые формализуют подходы к проектированию и нуждаются в опорном материале для code review, внутренних гайдлайнов или обучения команды.

Для углублённого изучения концепций воспользуйтесь аналитическими материалами автора примеров:

- [Паттерны ООП c примерами на Java: порождающие шаблоны](https://habr.com/p/955604/)
- [Паттерны ООП, так не издевались даже… Структурные шаблоны с примерами на Java](https://habr.com/p/957914/)

## Структурные паттерны
Структурные шаблоны упорядочивают связи между объектами и скрывают сложность реализации, позволяя расширять систему без изменения клиентского кода.

- **Adapter** — демонстрирует интеграцию внешнего API грузоперевозчика в унифицированный контракт `FreightCarrier`, устраняя необходимость модифицировать потребителей сервиса доставки.
- **Bridge** — разделяет абстракцию уведомления и каналы доставки, что позволяет независимо масштабировать типы событий и транспортные механизмы без роста матрицы `N×M` реализаций.
- **Composite** — формирует древовидное меню ресторана, делая операции визуализации и агрегирования единообразными для листьев и узлов иерархии.
- **Decorator** — наслаивает дополнительное поведение (логирование, повторные попытки) поверх базового отправителя сообщений, сохраняя единый контракт для клиента.
- **Facade** — предоставляет лаконичный интерфейс `DocumentFacade.create`, который инкапсулирует оркестрацию шаблонов, подписей и хранилища документов.
- **Flyweight** — иллюстрирует экономию памяти за счёт кэша неизменяемых объектов валюты и вынесения уникального состояния в отдельные экземпляры `Money`.
- **Proxy** — внедряет кэш над «тяжёлым» репозиторием пользователей, управляя доступом к базе и снижая задержки повторных запросов.

## Порождающие паттерны
Порождающие шаблоны фокусируются на контроле жизненного цикла объектов, обеспечивая согласованность инициализации и снижение связанности.

- **Factory Method** — переносит выбор реализации уведомлений в специализированные подклассы сервисов, оставляя клиентам только работу с абстракцией `AlertService`.
- **Abstract Factory** — конфигурирует согласованные пары продьюсеров и консъюмеров сообщений (Kafka/RabbitMQ) через единый интерфейс `MessagingFactory`, исключая несовместимые комбинации компонентов.【src/creational/abstractfactory/Main.java】
- **Builder** — обеспечивает пошаговую инициализацию заказов с валидацией обязательных полей и автоматическим заполнением служебных атрибутов 
- **Singleton** — гарантирует единственный экземпляр удалённой конфигурации и синхронизированную ленивую инициализацию через статический холдер.
- **Simple Factory** — инкапсулирует логику выбора канала уведомлений и поставляет совместимый `Notifier` в зависимости от параметров окружения.

## Как использовать материалы
1. Изучите соответствующий каталог `src/<семейство>/<паттерн>` и запустите `Main` для наблюдения поведенческих аспектов шаблона.
2. Проанализируйте встроенные комментарии — они описывают роли участников (Contract, Client, Facade и т. д.) и помогают адаптировать подход к вашим реалиям.
3. Используйте примеры в качестве прототипов при проектировании интеграций, построении модульных API и разработке внутренних стандартов качества.

## Требования к окружению
- Java 17+
- Maven или Gradle не требуются: примеры можно собрать и запустить через `javac` и `java`, указав пакет и файл `Main.java`.

## Обратная связь
Предложения по расширению каталога паттернов направляйте через pull request или issues. При добавлении новых примеров сохраняйте деловой стиль описания и фокус на практической применимости шаблонов в корпоративных проектах.

Следите за обновлениями и дополнительными материалами в Telegram-канале: [t.me/devbrombin](https://t.me/devbrombin).
